
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Finetuning_LM.ipynb
import pandas as pd
import numpy as np
from rdkit.Chem import AllChem, DataStructs, MolFromSmiles, MolToSmiles, MolFromSmarts, Draw
from rdkit.Chem.Scaffolds import MurckoScaffold
from rdkit import Chem
from rdkit.Chem.Descriptors import MolWt, MolLogP, NumHDonors, NumHAcceptors, TPSA
from rdkit.Chem.rdMolDescriptors import CalcNumRotatableBonds
from rdkit import Chem
from rdkit.Chem import RDConfig
from rdkit.Chem.FilterCatalog import *

import os
import sys
sys.path.append(os.path.join(RDConfig.RDContribDir, 'SA_Score'))
# now you can import sascore!
import sascorer

# from rdkit.DataManip.Metric import GetTanimotoDistMat
# from rdkit.DataManip.Metric import GetTanimotoSimMat
#rdBase.DisableLog('rdApp.error')
#rdBase.DisableLog('rdApp.info')

def get_scaffolds(mol):
  '''Exracts Bemis-Murcko scaffolds from a collection of molecules'''
  if type(mol) == str:
    return MurckoScaffold.MurckoScaffoldSmiles(mol)
  else:
    mol = MolToSmiles(mol)
    return MurckoScaffold.MurckoScaffoldSmiles(mol)

def calculate_fingerprints(mols, bits=1024, radius=2):
    return np.concatenate([np.asarray(AllChem.GetMorganFingerprintAsBitVect(x,nBits=bits,radius=radius)).reshape(1,bits) for x in mols])

def pairwise_simi(query_smiles,reference_smiles):
    '''Creates a pairwise similarity matrix for two fingerprints sets
    Inputs:
    mol1 - Query molecules
    mol2 - Reference molecules'''
    fp1,fp2 = map(calculate_fingerprints,[query_smiles,reference_smiles])

    matrix = np.zeros((len(fp1),len(fp2)))
    for i in range(matrix.shape[0]):
        for j in range(matrix.shape[1]):
            matrix[i,j] = DataStructs.TanimotoSimilarity(fp1[i],fp2[j])
    return matrix


def randomize_smiles(smi): return MolToSmiles(MolFromSmiles(smi),doRandom=True,canonical=False)

def smiles_augmentation(df,smiles_column, N_rounds):
    cols = [c for c in df.columns if c!=smiles_column]
    dist_aug = {smiles_column : []}

    
    duplicated_df = df[cols].append([df[cols]]*(N_rounds-1),ignore_index=False)
    
    for i in range(df.shape[0]):      
        for _ in range(N_rounds):
            dist_aug[smiles_column].append(randomize_smiles(df.iloc[i].smiles_column))
            
    assert len(dist_aug[smiles_column]) == duplicated_df.shape[0]
    duplicated_df.sort_index(inplace=True)
    duplicated_df.insert(loc=1, column=smiles_column, value=dist_aug[smiles_column])

    
    return duplicated_df.reset_index(drop=True)


def plot_most_similar(idx:int,k:int,simi_matrix,compound,reference):
    '''Plot the most similar and most dissimilar compounds to a random compound
      
    idx: Index of generated molecule
    k: Number of K reference compounds to compute similarity
    simi_matrix: Pairwise similarity matrix
    Compound: Query compund list
    Refrence: Reference compound list'''

    cmp_similarities =  np.argsort(simi_matrix[idx]) # Sorted similarities between a compound and all compounds of the reference set.
    lw = int(cmp_similarities[0])
    hg = int(cmp_similarities[-1])
    low_simi = simi_matrix[idx,lw] # Most dissimilar
    high_simi = simi_matrix[idx,hg] # Most similar

    legend = ['Most dissimilar ({:.3f})'.format(low_simi),'Generated','Most similar ({:.3f})'.format(high_simi)]
    print(lw,hg)

    rf1 = MolFromSmiles(reference[lw])
    rf2 = MolFromSmiles(reference[hg])
    cmpx = MolFromSmiles(compound[idx])

   # bb.append(high_simi)
    print(reference[lw],compound[idx],reference[hg])
    return Draw.MolsToGridImage(mols=[rf1, cmpx, rf2],useSVG=True,legends=legend,subImgSize=(400,400))